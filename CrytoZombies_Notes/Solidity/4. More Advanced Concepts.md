### Modifiers so far...
- Up until now, some function modifiers have been covered

1. Visibility Modifiers
	- These are modifiers that control when and where the function can be called from
	- `private` means it's only callable from other functions inside the contract
	- `internal` is like `private` but can also be called by contacts that **inherit** from this one
	- `external` can only be called outside the contract
	- `public` can be called anywhere, bth internally and externally

2. State Modifiers
	- These tell us how the function interacts with the BlockChain
	- `view` tells us that by running the function, no data will be saved/changed
	- `pure` tells us that not only does the function not save any data to the blockchain, but it also doesn't read any data from the blockchain
	- Both of these don't cost any gas to call if they're called externally from outside the contract
	- But they do cost gas if called internally by another function

3. Custom `modifier`
	- Ones that the developer defines and uses in various functions

- All of these modififers can be stacked together on a function defination as the follows

```solidity
function someFunc() external view onlyOwner anotherModifier {/* ... */}
```

### Payable 
- `payable` functions are part of what makes Solidity and Ethereum so cool
- Special type of function that can receive Ether
- For example, you can charge developers per API call to a specific function

```solidity
contract OnlineStore() 
{
	function buySomething() external payable {
		// check the value of ether sent to this function
		require(msg.value === 0.001 ether);
		// If so, some logic to transfer the digital item to the sender. 
		// Probably also take out monies from the sender here
		buyThing(msg.sender);
	}
}
```

- Someone could call the function using the following

```javascript
OnlineStore.buySomething({
	from: web3.eth.defaultAccount,
	value: web3.utils.toWei(0.001)
})
```
- Think of the transaction an envelope
	- The parameters you send to the function call are the contents of the letter
	- the `value` is like putting cash inside the envelope

**Note** - If a function is not marked `payable` and you try to send Ether to it as above, the function will reject the transaction


### Withdraws
- The following can be used to withdraw Ether from the contract as follows

```solidity
contract GiveMeMyMoney is Ownable {
	function withdraw() external onlyOwner{
		address payable _owner = address(uint160(owner()));
		_owner.transfer(address(this).balance);
	}
}
```

- It is important to note that you cannot transfer Ether to an address unless that address is of type `address payable`
- But the `_owner` variable is of type `uint160`, meaning we must explicity cast to `address payable`
- Once you cast the address from`uint160` to `address payable`
	- You can transfer Ether to that address using the `transfer` function and `address(this).balance` will return the total balance stored on the contract
- You can use `transfer` to send funds to any Ethereum address
- Example you could have a function that transfer Ether back to the `msg.sender`

```solidity
uint itemFee = 0.001 ether;
msg.sender.transfer(msg.value - itemFee) // Return change back
```

- Or in a contract with a buyer and seller, you could save the seller's address in storage
	- Then when someone purchases their item, transfer him the fee paid by the buy `seller.transfer(msg.value)`

### Random Numbers
